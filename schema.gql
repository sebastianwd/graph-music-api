# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregatePlaylist {
  _avg: PlaylistAvgAggregate
  _count: PlaylistCountAggregate
  _max: PlaylistMaxAggregate
  _min: PlaylistMinAggregate
  _sum: PlaylistSumAggregate
}

type AggregateSong {
  _avg: SongAvgAggregate
  _count: SongCountAggregate
  _max: SongMaxAggregate
  _min: SongMinAggregate
  _sum: SongSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyPlaylist(data: [PlaylistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySong(data: [SongCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createPlaylist(data: PlaylistCreateInput!): Playlist!
  createSong(data: SongCreateInput!): Song!
  createUser(data: UserCreateInput!): User!
  deleteManyPlaylist(where: PlaylistWhereInput): AffectedRowsOutput!
  deleteManySong(where: SongWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deletePlaylist(where: PlaylistWhereUniqueInput!): Playlist
  deleteSong(where: SongWhereUniqueInput!): Song
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyPlaylist(data: PlaylistUpdateManyMutationInput!, where: PlaylistWhereInput): AffectedRowsOutput!
  updateManySong(data: SongUpdateManyMutationInput!, where: SongWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updatePlaylist(data: PlaylistUpdateInput!, where: PlaylistWhereUniqueInput!): Playlist
  updateSong(data: SongUpdateInput!, where: SongWhereUniqueInput!): Song
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertPlaylist(create: PlaylistCreateInput!, update: PlaylistUpdateInput!, where: PlaylistWhereUniqueInput!): Playlist!
  upsertSong(create: SongCreateInput!, update: SongUpdateInput!, where: SongWhereUniqueInput!): Song!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Playlist {
  User: User!
  _count: PlaylistCount
  createdAt: DateTime!
  name: String!
  songs(cursor: SongWhereUniqueInput, distinct: [SongScalarFieldEnum!], orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): [Song!]!
  updatedAt: DateTime!
  userId: Int!
}

type PlaylistAvgAggregate {
  id: Float
  userId: Float
}

input PlaylistAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type PlaylistCount {
  songs: Int!
}

type PlaylistCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
  userId: Int!
}

input PlaylistCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlaylistCreateInput {
  User: UserCreateNestedOneWithoutPlaylistsInput!
  createdAt: DateTime
  name: String!
  songs: SongCreateNestedManyWithoutPlaylistInput
  updatedAt: DateTime
}

input PlaylistCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
  userId: Int!
}

input PlaylistCreateManyUserInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input PlaylistCreateManyUserInputEnvelope {
  data: [PlaylistCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PlaylistCreateNestedManyWithoutUserInput {
  connect: [PlaylistWhereUniqueInput!]
  connectOrCreate: [PlaylistCreateOrConnectWithoutUserInput!]
  create: [PlaylistCreateWithoutUserInput!]
  createMany: PlaylistCreateManyUserInputEnvelope
}

input PlaylistCreateNestedOneWithoutSongsInput {
  connect: PlaylistWhereUniqueInput
  connectOrCreate: PlaylistCreateOrConnectWithoutSongsInput
  create: PlaylistCreateWithoutSongsInput
}

input PlaylistCreateOrConnectWithoutSongsInput {
  create: PlaylistCreateWithoutSongsInput!
  where: PlaylistWhereUniqueInput!
}

input PlaylistCreateOrConnectWithoutUserInput {
  create: PlaylistCreateWithoutUserInput!
  where: PlaylistWhereUniqueInput!
}

input PlaylistCreateWithoutSongsInput {
  User: UserCreateNestedOneWithoutPlaylistsInput!
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input PlaylistCreateWithoutUserInput {
  createdAt: DateTime
  name: String!
  songs: SongCreateNestedManyWithoutPlaylistInput
  updatedAt: DateTime
}

type PlaylistGroupBy {
  _avg: PlaylistAvgAggregate
  _count: PlaylistCountAggregate
  _max: PlaylistMaxAggregate
  _min: PlaylistMinAggregate
  _sum: PlaylistSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
  userId: Int!
}

input PlaylistListRelationFilter {
  every: PlaylistWhereInput
  none: PlaylistWhereInput
  some: PlaylistWhereInput
}

type PlaylistMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  userId: Int
}

input PlaylistMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PlaylistMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  userId: Int
}

input PlaylistMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlaylistOrderByRelationAggregateInput {
  _count: SortOrder
}

input PlaylistOrderByWithAggregationInput {
  _avg: PlaylistAvgOrderByAggregateInput
  _count: PlaylistCountOrderByAggregateInput
  _max: PlaylistMaxOrderByAggregateInput
  _min: PlaylistMinOrderByAggregateInput
  _sum: PlaylistSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PlaylistOrderByWithRelationInput {
  User: UserOrderByWithRelationInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  songs: SongOrderByRelationAggregateInput
  updatedAt: SortOrder
  userId: SortOrder
}

input PlaylistRelationFilter {
  is: PlaylistWhereInput
  isNot: PlaylistWhereInput
}

enum PlaylistScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
  userId
}

input PlaylistScalarWhereInput {
  AND: [PlaylistScalarWhereInput!]
  NOT: [PlaylistScalarWhereInput!]
  OR: [PlaylistScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PlaylistScalarWhereWithAggregatesInput {
  AND: [PlaylistScalarWhereWithAggregatesInput!]
  NOT: [PlaylistScalarWhereWithAggregatesInput!]
  OR: [PlaylistScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type PlaylistSumAggregate {
  id: Int
  userId: Int
}

input PlaylistSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input PlaylistUpdateInput {
  User: UserUpdateOneRequiredWithoutPlaylistsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  songs: SongUpdateManyWithoutPlaylistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlaylistUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlaylistUpdateManyWithWhereWithoutUserInput {
  data: PlaylistUpdateManyMutationInput!
  where: PlaylistScalarWhereInput!
}

input PlaylistUpdateManyWithoutUserInput {
  connect: [PlaylistWhereUniqueInput!]
  connectOrCreate: [PlaylistCreateOrConnectWithoutUserInput!]
  create: [PlaylistCreateWithoutUserInput!]
  createMany: PlaylistCreateManyUserInputEnvelope
  delete: [PlaylistWhereUniqueInput!]
  deleteMany: [PlaylistScalarWhereInput!]
  disconnect: [PlaylistWhereUniqueInput!]
  set: [PlaylistWhereUniqueInput!]
  update: [PlaylistUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PlaylistUpdateManyWithWhereWithoutUserInput!]
  upsert: [PlaylistUpsertWithWhereUniqueWithoutUserInput!]
}

input PlaylistUpdateOneWithoutSongsInput {
  connect: PlaylistWhereUniqueInput
  connectOrCreate: PlaylistCreateOrConnectWithoutSongsInput
  create: PlaylistCreateWithoutSongsInput
  delete: Boolean
  disconnect: Boolean
  update: PlaylistUpdateWithoutSongsInput
  upsert: PlaylistUpsertWithoutSongsInput
}

input PlaylistUpdateWithWhereUniqueWithoutUserInput {
  data: PlaylistUpdateWithoutUserInput!
  where: PlaylistWhereUniqueInput!
}

input PlaylistUpdateWithoutSongsInput {
  User: UserUpdateOneRequiredWithoutPlaylistsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlaylistUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  songs: SongUpdateManyWithoutPlaylistInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlaylistUpsertWithWhereUniqueWithoutUserInput {
  create: PlaylistCreateWithoutUserInput!
  update: PlaylistUpdateWithoutUserInput!
  where: PlaylistWhereUniqueInput!
}

input PlaylistUpsertWithoutSongsInput {
  create: PlaylistCreateWithoutSongsInput!
  update: PlaylistUpdateWithoutSongsInput!
}

input PlaylistWhereInput {
  AND: [PlaylistWhereInput!]
  NOT: [PlaylistWhereInput!]
  OR: [PlaylistWhereInput!]
  User: UserRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  songs: SongListRelationFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PlaylistWhereUniqueInput {
  id: Int
}

type Query {
  aggregatePlaylist(cursor: PlaylistWhereUniqueInput, orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): AggregatePlaylist!
  aggregateSong(cursor: SongWhereUniqueInput, orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): AggregateSong!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstPlaylist(cursor: PlaylistWhereUniqueInput, distinct: [PlaylistScalarFieldEnum!], orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): Playlist
  findFirstSong(cursor: SongWhereUniqueInput, distinct: [SongScalarFieldEnum!], orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): Song
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByPlaylist(by: [PlaylistScalarFieldEnum!]!, having: PlaylistScalarWhereWithAggregatesInput, orderBy: [PlaylistOrderByWithAggregationInput!], skip: Int, take: Int, where: PlaylistWhereInput): [PlaylistGroupBy!]!
  groupBySong(by: [SongScalarFieldEnum!]!, having: SongScalarWhereWithAggregatesInput, orderBy: [SongOrderByWithAggregationInput!], skip: Int, take: Int, where: SongWhereInput): [SongGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  me: User
  playlist(where: PlaylistWhereUniqueInput!): Playlist
  playlists(cursor: PlaylistWhereUniqueInput, distinct: [PlaylistScalarFieldEnum!], orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): [Playlist!]!
  song(where: SongWhereUniqueInput!): Song
  songs(cursor: SongWhereUniqueInput, distinct: [SongScalarFieldEnum!], orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): [Song!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Song {
  Playlist: Playlist
  album: String
  artist: String!
  duration: Int
  genre: String
  playlistId: Int
  title: String!
  year: Int
}

type SongAvgAggregate {
  duration: Float
  id: Float
  playlistId: Float
  year: Float
}

input SongAvgOrderByAggregateInput {
  duration: SortOrder
  id: SortOrder
  playlistId: SortOrder
  year: SortOrder
}

type SongCountAggregate {
  _all: Int!
  album: Int!
  artist: Int!
  duration: Int!
  genre: Int!
  id: Int!
  playlistId: Int!
  title: Int!
  year: Int!
}

input SongCountOrderByAggregateInput {
  album: SortOrder
  artist: SortOrder
  duration: SortOrder
  genre: SortOrder
  id: SortOrder
  playlistId: SortOrder
  title: SortOrder
  year: SortOrder
}

input SongCreateInput {
  Playlist: PlaylistCreateNestedOneWithoutSongsInput
  album: String
  artist: String!
  duration: Int
  genre: String
  title: String!
  year: Int
}

input SongCreateManyInput {
  album: String
  artist: String!
  duration: Int
  genre: String
  id: Int
  playlistId: Int
  title: String!
  year: Int
}

input SongCreateManyPlaylistInput {
  album: String
  artist: String!
  duration: Int
  genre: String
  id: Int
  title: String!
  year: Int
}

input SongCreateManyPlaylistInputEnvelope {
  data: [SongCreateManyPlaylistInput!]!
  skipDuplicates: Boolean
}

input SongCreateNestedManyWithoutPlaylistInput {
  connect: [SongWhereUniqueInput!]
  connectOrCreate: [SongCreateOrConnectWithoutPlaylistInput!]
  create: [SongCreateWithoutPlaylistInput!]
  createMany: SongCreateManyPlaylistInputEnvelope
}

input SongCreateOrConnectWithoutPlaylistInput {
  create: SongCreateWithoutPlaylistInput!
  where: SongWhereUniqueInput!
}

input SongCreateWithoutPlaylistInput {
  album: String
  artist: String!
  duration: Int
  genre: String
  title: String!
  year: Int
}

type SongGroupBy {
  _avg: SongAvgAggregate
  _count: SongCountAggregate
  _max: SongMaxAggregate
  _min: SongMinAggregate
  _sum: SongSumAggregate
  album: String
  artist: String!
  duration: Int
  genre: String
  id: Int!
  playlistId: Int
  title: String!
  year: Int
}

input SongListRelationFilter {
  every: SongWhereInput
  none: SongWhereInput
  some: SongWhereInput
}

type SongMaxAggregate {
  album: String
  artist: String
  duration: Int
  genre: String
  id: Int
  playlistId: Int
  title: String
  year: Int
}

input SongMaxOrderByAggregateInput {
  album: SortOrder
  artist: SortOrder
  duration: SortOrder
  genre: SortOrder
  id: SortOrder
  playlistId: SortOrder
  title: SortOrder
  year: SortOrder
}

type SongMinAggregate {
  album: String
  artist: String
  duration: Int
  genre: String
  id: Int
  playlistId: Int
  title: String
  year: Int
}

input SongMinOrderByAggregateInput {
  album: SortOrder
  artist: SortOrder
  duration: SortOrder
  genre: SortOrder
  id: SortOrder
  playlistId: SortOrder
  title: SortOrder
  year: SortOrder
}

input SongOrderByRelationAggregateInput {
  _count: SortOrder
}

input SongOrderByWithAggregationInput {
  _avg: SongAvgOrderByAggregateInput
  _count: SongCountOrderByAggregateInput
  _max: SongMaxOrderByAggregateInput
  _min: SongMinOrderByAggregateInput
  _sum: SongSumOrderByAggregateInput
  album: SortOrder
  artist: SortOrder
  duration: SortOrder
  genre: SortOrder
  id: SortOrder
  playlistId: SortOrder
  title: SortOrder
  year: SortOrder
}

input SongOrderByWithRelationInput {
  Playlist: PlaylistOrderByWithRelationInput
  album: SortOrder
  artist: SortOrder
  duration: SortOrder
  genre: SortOrder
  id: SortOrder
  playlistId: SortOrder
  title: SortOrder
  year: SortOrder
}

enum SongScalarFieldEnum {
  album
  artist
  duration
  genre
  id
  playlistId
  title
  year
}

input SongScalarWhereInput {
  AND: [SongScalarWhereInput!]
  NOT: [SongScalarWhereInput!]
  OR: [SongScalarWhereInput!]
  album: StringNullableFilter
  artist: StringFilter
  duration: IntNullableFilter
  genre: StringNullableFilter
  id: IntFilter
  playlistId: IntNullableFilter
  title: StringFilter
  year: IntNullableFilter
}

input SongScalarWhereWithAggregatesInput {
  AND: [SongScalarWhereWithAggregatesInput!]
  NOT: [SongScalarWhereWithAggregatesInput!]
  OR: [SongScalarWhereWithAggregatesInput!]
  album: StringNullableWithAggregatesFilter
  artist: StringWithAggregatesFilter
  duration: IntNullableWithAggregatesFilter
  genre: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  playlistId: IntNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  year: IntNullableWithAggregatesFilter
}

type SongSumAggregate {
  duration: Int
  id: Int
  playlistId: Int
  year: Int
}

input SongSumOrderByAggregateInput {
  duration: SortOrder
  id: SortOrder
  playlistId: SortOrder
  year: SortOrder
}

input SongUpdateInput {
  Playlist: PlaylistUpdateOneWithoutSongsInput
  album: NullableStringFieldUpdateOperationsInput
  artist: StringFieldUpdateOperationsInput
  duration: NullableIntFieldUpdateOperationsInput
  genre: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SongUpdateManyMutationInput {
  album: NullableStringFieldUpdateOperationsInput
  artist: StringFieldUpdateOperationsInput
  duration: NullableIntFieldUpdateOperationsInput
  genre: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SongUpdateManyWithWhereWithoutPlaylistInput {
  data: SongUpdateManyMutationInput!
  where: SongScalarWhereInput!
}

input SongUpdateManyWithoutPlaylistInput {
  connect: [SongWhereUniqueInput!]
  connectOrCreate: [SongCreateOrConnectWithoutPlaylistInput!]
  create: [SongCreateWithoutPlaylistInput!]
  createMany: SongCreateManyPlaylistInputEnvelope
  delete: [SongWhereUniqueInput!]
  deleteMany: [SongScalarWhereInput!]
  disconnect: [SongWhereUniqueInput!]
  set: [SongWhereUniqueInput!]
  update: [SongUpdateWithWhereUniqueWithoutPlaylistInput!]
  updateMany: [SongUpdateManyWithWhereWithoutPlaylistInput!]
  upsert: [SongUpsertWithWhereUniqueWithoutPlaylistInput!]
}

input SongUpdateWithWhereUniqueWithoutPlaylistInput {
  data: SongUpdateWithoutPlaylistInput!
  where: SongWhereUniqueInput!
}

input SongUpdateWithoutPlaylistInput {
  album: NullableStringFieldUpdateOperationsInput
  artist: StringFieldUpdateOperationsInput
  duration: NullableIntFieldUpdateOperationsInput
  genre: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SongUpsertWithWhereUniqueWithoutPlaylistInput {
  create: SongCreateWithoutPlaylistInput!
  update: SongUpdateWithoutPlaylistInput!
  where: SongWhereUniqueInput!
}

input SongWhereInput {
  AND: [SongWhereInput!]
  NOT: [SongWhereInput!]
  OR: [SongWhereInput!]
  Playlist: PlaylistRelationFilter
  album: StringNullableFilter
  artist: StringFilter
  duration: IntNullableFilter
  genre: StringNullableFilter
  id: IntFilter
  playlistId: IntNullableFilter
  title: StringFilter
  year: IntNullableFilter
}

input SongWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String!

  """The global ID of the object."""
  id: ID!
  name: String
  password: String!
  playlists(cursor: PlaylistWhereUniqueInput, distinct: [PlaylistScalarFieldEnum!], orderBy: [PlaylistOrderByWithRelationInput!], skip: Int, take: Int, where: PlaylistWhereInput): [Playlist!]!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  playlists: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String
  password: String!
  playlists: PlaylistCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  id: Int
  name: String
  password: String!
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutPlaylistsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPlaylistsInput
  create: UserCreateWithoutPlaylistsInput
}

input UserCreateOrConnectWithoutPlaylistsInput {
  create: UserCreateWithoutPlaylistsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPlaylistsInput {
  createdAt: DateTime
  email: String!
  name: String
  password: String!
  updatedAt: DateTime
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String
  password: String!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  playlists: PlaylistOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  password
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  password: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  playlists: PlaylistUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutPlaylistsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPlaylistsInput
  create: UserCreateWithoutPlaylistsInput
  update: UserUpdateWithoutPlaylistsInput
  upsert: UserUpsertWithoutPlaylistsInput
}

input UserUpdateWithoutPlaylistsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutPlaylistsInput {
  create: UserCreateWithoutPlaylistsInput!
  update: UserUpdateWithoutPlaylistsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringNullableFilter
  password: StringFilter
  playlists: PlaylistListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
